# Windows输入法光标定位与候选词显示修复设计文档

## 一、问题概述

当前UTIME输入法项目存在三个核心问题：

1. **光标位置获取失败** - 候选词窗口无法正确定位在光标附近
2. **候选词无法搜索和显示** - 词典查询失败，候选列表为空或只显示原始拼音
3. **输入内容无法发送到目标程序** - 用户输入的文字无法提交到应用程序

这些问题导致输入法基本功能完全失效，用户无法正常使用该输入法进行中文输入。

## 二、根因分析

### 2.1 光标位置获取失败

**问题定位**

在 `TextService.cpp` 的 `_UpdateCandidateWindow` 方法（第300-429行）中，系统尝试通过以下方式获取光标位置：

1. 首先通过 `GetTextExt` API 获取选区矩形
2. 如果失败，尝试使用 `GetGUIThreadInfo` 获取目标窗口的光标信息
3. 最终回退到 `GetCursorPos` 获取鼠标位置

**失败原因**

| 失败场景 | 原因 |
|---------|------|
| GetTextExt返回空矩形 | 某些应用程序（如记事本、Chrome等）未正确实现TSF的 `ITfContextView::GetTextExt` 接口 |
| GetGUIThreadInfo失败 | 需要正确的目标窗口句柄；某些UI框架的输入控件不是顶层窗口，导致句柄获取错误 |
| 窗口句柄获取失败 | `ITfContextView::GetWnd` 在某些应用中返回NULL或失败 |
| 跨进程/跨线程限制 | 输入法运行在独立进程，某些系统API在跨进程调用时受到权限限制 |

**技术细节**

当前实现中存在的问题：

- 同步编辑会话（TF_ES_SYNC）可能被某些应用拒绝
- 没有正确处理编辑会话返回的HRESULT错误码
- 窗口句柄的获取时机不正确，应该在编辑会话外获取
- 缺少对 `ITfContextOwnerCompositionSink` 接口的支持，无法接收应用程序主动提供的光标位置信息

### 2.2 候选词无法搜索和显示

**问题定位**

候选词系统涉及两个核心组件：

1. **词典引擎** (`DictionaryEngine.cpp`) - 负责从SQLite数据库查询候选词
2. **候选窗口** (`CandidateWindow.cpp`) - 负责显示候选词列表

**失败原因**

| 组件 | 潜在问题 | 影响 |
|------|---------|------|
| 数据库初始化 | 数据库文件路径错误或文件不存在 | 查询始终返回空结果 |
| 数据库初始化 | 从DLL目录复制数据库失败（权限或路径问题） | 初始化失败，`_isInitialized` 为false |
| SQL查询逻辑 | 动态SQL构建错误或绑定参数失败 | 查询无结果或崩溃 |
| 编码问题 | 拼音或汉字的UTF-8/UTF-16转换错误 | 查询不到匹配结果 |
| 日志输出 | DebugLog写入文件失败，无法诊断问题 | 无法定位实际错误 |

**技术细节**

当前实现的风险点：

- `Initialize` 方法依赖 `SHGetFolderPath` 获取AppData路径，可能在某些系统配置下失败
- 数据库文件需要从DLL所在目录复制到AppData，如果DLL目录不包含 `utime.db` 文件则必然失败
- 查询时使用 `SQLITE_STATIC` 标志绑定参数，但参数字符串可能在 `sqlite3_step` 前被销毁
- 模糊匹配逻辑生成多个查询变体，SQL语句动态构建可能存在语法错误

### 2.3 输入内容无法发送到目标程序

**问题定位**

在 `TextService.cpp` 的 `OnKeyDown` 方法（第191-216行）处理空格键提交逻辑：

```
当用户按下空格键时：
1. 创建 CUpdateCompositionEditSession 更新组合文本为候选词
2. 调用 RequestEditSession 异步提交
3. 调用 _EndComposition 结束组合
4. 清空内部缓冲区
```

**失败原因**

| 问题 | 原因 | 影响 |
|------|------|------|
| 异步编辑会话未完成 | 使用 `TF_ES_ASYNCDONTCARE` 标志，编辑会话可能在 `_EndComposition` 之后才执行 | 文本未插入就结束组合，导致内容丢失 |
| 组合状态不一致 | 连续调用两个异步编辑会话，执行顺序无法保证 | 可能先结束组合再设置文本，导致操作失败 |
| 错误处理缺失 | 未检查 `RequestEditSession` 的返回值 | 请求失败时无提示，用户体验差 |
| 组合范围无效 | `_pComposition` 可能为NULL或已被应用程序终止 | 访问空指针或操作无效组合导致崩溃 |

**技术细节**

TSF编辑会话的关键约束：

- 异步编辑会话不保证执行顺序和时机
- 组合结束后，组合范围立即失效，无法再修改文本
- 正确的提交流程应该是：在组合结束时直接提交最终文本，而非分两步操作
- 需要在 `EndComposition` 前确保所有文本更新已完成

## 三、解决方案设计

### 3.1 光标位置获取优化方案

**设计目标**

建立多层级、容错性强的光标位置获取机制，确保在各种应用环境下都能获得可用的候选窗口定位坐标。

**方案架构**

采用责任链模式，按优先级依次尝试以下策略：

| 优先级 | 策略 | 适用场景 | 预期成功率 |
|--------|------|---------|-----------|
| 1 | TSF GetTextExt API | 完整实现TSF的应用（Word、Outlook） | 40% |
| 2 | ITfContextOwner获取插入点 | 支持TSF但未实现GetTextExt的应用 | 30% |
| 3 | GetGUIThreadInfo + 窗口句柄 | 传统Win32应用（记事本、旧版浏览器） | 60% |
| 4 | ImmGetCompositionWindow | 支持IMM32的应用 | 50% |
| 5 | GetCaretPos + 焦点窗口 | 同进程或输入法进程的控件 | 20% |
| 6 | 鼠标位置回退 | 所有场景 | 100% |

**实施细节**

创建独立的光标位置获取类：

**类职责**：CCursorPositionProvider

**主要方法**：

| 方法 | 返回值 | 说明 |
|------|--------|------|
| GetCursorPosition | POINT | 获取光标屏幕坐标（必定成功） |
| GetCursorRect | RECT | 获取光标矩形区域（可能失败） |
| IsPositionValid | bool | 验证坐标是否有效（非0,0点） |

**GetCursorPosition伪流程**：

1. 尝试通过TSF GetTextExt获取选区位置
   - 创建异步只读编辑会话
   - 调用 `ITfContext::GetSelection` 获取当前选区
   - 调用 `ITfContextView::GetTextExt` 获取选区屏幕矩形
   - 如果成功且矩形有效，返回矩形左下角坐标

2. 尝试通过ITfContextOwner获取插入点
   - 查询ITfContext的ITfContextOwner接口
   - 调用 `GetACPFromPoint` 或相关方法获取活动插入点
   - 如果成功，将ACP转换为屏幕坐标

3. 尝试通过GetGUIThreadInfo获取光标
   - 调用 `ITfContextView::GetWnd` 获取目标窗口句柄
   - 如果失败，通过 `GetForegroundWindow` 获取前台窗口
   - 调用 `GetWindowThreadProcessId` 获取窗口线程ID
   - 调用 `GetGUIThreadInfo` 获取GUI线程的光标信息
   - 使用 `ClientToScreen` 将客户区坐标转换为屏幕坐标

4. 尝试通过ImmGetCompositionWindow获取
   - 获取目标窗口的输入上下文句柄（HIMC）
   - 调用 `ImmGetCompositionWindow` 获取组合窗口位置
   - 转换为屏幕坐标

5. 尝试通过GetCaretPos获取
   - 调用 `GetCaretPos` 获取光标客户区坐标
   - 使用焦点窗口句柄转换为屏幕坐标

6. 回退到鼠标位置
   - 调用 `GetCursorPos` 获取鼠标屏幕坐标
   - 在Y轴方向偏移20像素，避免遮挡

**错误处理**

- 每个策略失败时记录DebugLog，包含具体错误码
- 使用位标记记录哪些策略已尝试，避免重复
- 提供诊断模式，输出详细的尝试路径和失败原因

### 3.2 候选词搜索修复方案

**设计目标**

确保词典引擎能够正确初始化、查询数据库，并返回有效的候选词列表。

**数据库初始化流程优化**

当前流程存在的问题及改进：

| 步骤 | 当前实现 | 问题 | 改进方案 |
|------|---------|------|---------|
| 获取数据库路径 | 使用AppData\UTIME\utime.db | AppData可能不存在或无写权限 | 增加回退路径：DLL目录 → 临时目录 → 只读模式 |
| 检查数据库存在性 | 使用GetFileAttributes | 不验证文件完整性 | 增加文件大小和内容验证 |
| 复制数据库 | 从DLL目录复制到AppData | DLL目录可能没有源文件 | 优先使用AppData，不存在时直接从DLL目录打开（只读） |
| 打开数据库 | sqlite3_open | 未检查数据库表结构 | 打开后验证lexicon表是否存在 |
| 错误处理 | 失败时返回false | 无详细错误信息 | 记录每个步骤的失败原因到日志 |

**改进的初始化流程**

伪代码逻辑：

```
初始化数据库：
1. 构建候选路径列表：
   - 路径1：AppData\UTIME\utime.db（可读写）
   - 路径2：DLL目录\utime.db（只读）
   - 路径3：Windows\Temp\UTIME\utime.db（可读写）

2. 对于每个路径：
   - 如果文件存在：
     - 尝试打开数据库
     - 验证表结构（执行测试查询）
     - 如果成功，标记为已初始化并返回
   - 如果文件不存在且路径可写：
     - 尝试从DLL目录复制源数据库
     - 如果复制成功，跳转到验证步骤

3. 如果所有路径都失败：
   - 记录详细错误日志
   - 尝试创建空数据库并初始化基本表结构（应急方案）
   - 返回初始化失败
```

**查询逻辑修复**

当前查询存在的风险：

1. **参数绑定生命周期问题**
   - 问题：使用 `SQLITE_STATIC` 标志，要求字符串在执行期间有效
   - 修复：改用 `SQLITE_TRANSIENT` 标志，让SQLite复制字符串数据

2. **SQL注入风险**
   - 问题：虽然使用了参数化查询，但SQL语句动态拼接可能引入错误
   - 修复：预编译固定数量的查询语句，避免动态构建

3. **编码转换错误**
   - 问题：UTF-16（wstring）到UTF-8（SQLite）的转换可能失败
   - 修复：增加转换失败检查，使用 `WideCharToMultiByte` 的返回值验证

**优化后的查询流程**

```
查询候选词(拼音输入):
1. 输入验证：
   - 如果数据库未初始化，返回空列表
   - 如果输入为空，返回空列表

2. 编码转换：
   - 将wstring转换为UTF-8字符串
   - 检查转换结果，如果失败返回空列表
   - 转换为小写

3. 模糊匹配处理：
   - 应用自动纠错（AutoCorrect）
   - 生成模糊变体（GetFuzzyList）
   - 限制变体数量为5个以内（性能考虑）

4. 构建查询：
   - 使用预定义SQL模板（支持1-5个变体）
   - 选择对应变体数量的SQL语句

5. 执行查询：
   - 绑定参数时使用SQLITE_TRANSIENT标志
   - 逐行获取结果，转换为wstring
   - 使用set去重，避免重复候选词
   - 限制结果数量为20个

6. 结果处理：
   - 如果查询失败，记录SQL错误消息
   - 如果结果为空，不添加回退候选词（让上层决定）
   - 返回候选词列表
```

**日志增强**

在关键步骤增加调试日志：

| 日志点 | 记录内容 | 用途 |
|--------|---------|------|
| 初始化开始 | 尝试的路径 | 诊断路径问题 |
| 数据库打开 | 路径和SQLite错误码 | 诊断权限和文件问题 |
| 表验证 | SQL语句和执行结果 | 诊断数据库结构问题 |
| 查询开始 | 输入拼音和变体列表 | 验证模糊匹配逻辑 |
| 查询执行 | SQL语句和绑定参数 | 诊断SQL错误 |
| 查询结果 | 候选词数量和前3个结果 | 验证查询有效性 |

### 3.3 文字输入提交修复方案

**设计目标**

确保用户输入的文字能够正确提交到目标应用程序，解决异步编辑会话的时序问题。

**问题根源**

当前实现的时序问题示意：

```
用户按下空格键（期望）：
1. 更新组合文本为"你好"
2. 结束组合
3. 文字"你好"插入到应用程序

实际执行时序（异步问题）：
1. 请求异步更新会话（加入队列）
2. 请求异步结束会话（加入队列）
3. 立即清空内部缓冲区
4. [某个时间后] 结束会话执行 -> 组合被终止
5. [某个时间后] 更新会话执行 -> 组合已失效，更新失败
```

**解决方案：同步提交模式**

采用同步编辑会话确保操作顺序：

**方案对比**

| 方案 | 优点 | 缺点 | 选择 |
|------|------|------|------|
| 异步双会话 | 不阻塞UI | 时序无法保证 | ❌ 当前问题所在 |
| 同步双会话 | 时序正确 | 可能阻塞UI；某些应用拒绝同步请求 | ⚠️ 备选方案 |
| 单次同步提交会话 | 时序正确；操作原子化 | 略微阻塞；需重构会话类 | ✅ 推荐方案 |
| 异步回调链 | 不阻塞UI；时序正确 | 实现复杂 | ⚠️ 高级方案 |

**推荐方案：单次提交会话**

创建新的编辑会话类：CCommitCompositionEditSession

**类职责**

在单个编辑会话中完成文本提交和组合结束。

**执行逻辑**

```
DoEditSession(ec):
1. 验证组合有效性：
   - 如果_pComposition为NULL，直接返回失败
   
2. 获取组合范围：
   - 调用_pComposition->GetRange获取ITfRange

3. 更新组合文本为最终内容：
   - 调用range->SetText设置提交文本（候选词或原始拼音）
   
4. 调整选区到组合末尾：
   - 克隆范围
   - 折叠到末尾
   - 设置上下文选区

5. 结束组合：
   - 调用_pComposition->EndComposition(ec)
   - 注意：必须使用同一个编辑cookie

6. 清理：
   - 释放范围对象
   - 返回成功
```

**调用方式**

在OnKeyDown的空格键处理中：

```
当按下空格键：
1. 准备提交文本：
   - 如果有候选词，使用第一个候选词
   - 否则使用原始拼音

2. 创建提交会话：
   - 传入提交文本和当前上下文

3. 请求同步可读写会话：
   - 使用TF_ES_SYNC | TF_ES_READWRITE标志
   - 传出HRESULT以检查结果

4. 检查结果：
   - 如果返回TF_E_SYNCHRONOUS（应用不支持同步），回退到异步方案
   - 如果返回其他错误，记录日志并尝试强制清理

5. 清理状态：
   - 清空内部组合缓冲区
   - 清空候选词列表
   - 隐藏候选窗口
```

**容错处理**

| 错误情况 | 处理策略 |
|---------|---------|
| 应用拒绝同步请求 | 回退到异步双会话方案，接受时序风险 |
| 组合已被应用终止 | 检查_pComposition有效性，如果无效则尝试直接插入文本 |
| SetText失败 | 记录错误但继续结束组合，避免残留组合状态 |
| EndComposition失败 | 强制释放_pComposition引用，防止内存泄漏 |

**备选方案：异步回调链**

如果同步方案在某些应用中仍有问题，实施异步回调机制：

```
实现思路：
1. 创建状态机跟踪编辑会话状态
2. 第一个异步会话完成后触发回调
3. 在回调中启动第二个异步会话
4. 使用引用计数确保对象生命周期

复杂度：
- 需要实现回调接口
- 需要管理会话间的依赖关系
- 需要处理会话失败的回滚逻辑

适用场景：
- 目标应用严格拒绝同步请求
- 性能敏感场景（如游戏内输入）
```

### 3.4 综合调试与验证机制

**设计目标**

建立完善的日志和诊断体系，便于快速定位问题。

**日志系统增强**

当前DebugLog的问题：

- 文件写入可能失败（权限、磁盘满）
- 没有日志级别区分
- 缺少时间戳
- 多线程写入可能冲突

**改进方案**

| 改进项 | 实施细节 |
|--------|---------|
| 日志级别 | 增加ERROR、WARN、INFO、DEBUG四个级别 |
| 时间戳 | 每条日志前添加 [YYYY-MM-DD HH:MM:SS.mmm] 格式时间 |
| 线程安全 | 使用临界区（CRITICAL_SECTION）保护文件写入 |
| 回退机制 | 文件写入失败时仅使用OutputDebugString |
| 日志轮转 | 日志文件超过10MB时自动创建新文件 |
| 性能优化 | 使用缓冲区，定时刷新而非每次写入 |

**诊断命令接口**

通过注册表键值提供诊断控制：

| 注册表路径 | 键名 | 值 | 效果 |
|-----------|------|-----|------|
| HKEY_CURRENT_USER\Software\UTIME | LogLevel | 0-3 | 控制日志详细程度 |
| HKEY_CURRENT_USER\Software\UTIME | DiagnosticMode | 1 | 启用详细诊断（性能影响） |
| HKEY_CURRENT_USER\Software\UTIME | ShowDebugWindow | 1 | 显示调试信息窗口 |

**关键路径埋点**

在以下关键点增加日志：

```
光标位置获取：
- 每个策略的尝试和结果
- 最终使用的坐标和策略

候选词查询：
- 输入拼音
- 模糊变体列表
- SQL语句和参数
- 查询耗时
- 返回结果数量

文字提交：
- 提交文本内容
- 编辑会话请求结果
- SetText和EndComposition的返回值
- 最终组合状态
```

**验证测试场景**

为确保修复有效，需在以下应用中验证：

| 应用类型 | 典型应用 | 验证重点 |
|---------|---------|---------|
| 原生Win32 | 记事本、写字板 | 基本输入、光标跟随 |
| Office应用 | Word、Excel | TSF完整支持验证 |
| 浏览器 | Chrome、Edge、Firefox | 跨进程输入、Web控件 |
| 现代UWP | Windows Terminal、OneNote | UWP框架兼容性 |
| 聊天应用 | 微信、QQ | 实时输入场景 |
| IDE | VS Code、Visual Studio | 编辑器特殊处理 |

## 四、实施计划

### 4.1 修改范围评估

需要修改的文件：

| 文件 | 修改类型 | 工作量 | 风险 |
|------|---------|-------|------|
| TextService.h | 新增方法声明 | 小 | 低 |
| TextService.cpp | 重构光标获取、修复提交逻辑 | 大 | 中 |
| EditSession.h | 新增提交会话类 | 小 | 低 |
| EditSession.cpp | 实现提交会话 | 中 | 中 |
| DictionaryEngine.cpp | 优化初始化和查询 | 中 | 中 |
| Globals.h | 增强日志系统 | 小 | 低 |

### 4.2 实施优先级

| 阶段 | 任务 | 目标 | 预期效果 |
|------|------|------|---------|
| P0 | 修复文字提交逻辑 | 用户能输入文字到应用 | 输入法可用 |
| P0 | 修复数据库初始化 | 候选词能正常查询 | 显示正确候选词 |
| P1 | 优化光标位置获取 | 候选窗口位置准确 | 用户体验提升 |
| P2 | 增强日志系统 | 便于问题诊断 | 可维护性提升 |
| P3 | 多应用兼容性测试 | 确保广泛兼容 | 稳定性提升 |

### 4.3 回滚策略

如果修复引入新问题，回滚方案：

1. **保留原始实现** - 通过预处理宏开关新旧实现
2. **分步提交** - 每个修复独立提交，便于逐个回滚
3. **版本标记** - 在候选窗口标题显示版本号，便于识别

## 五、风险评估

### 5.1 技术风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| 同步编辑会话被某些应用拒绝 | 中 | 高 | 实现异步回退方案 |
| 光标获取在某些应用仍失败 | 中 | 中 | 使用鼠标位置回退 |
| 数据库文件无法复制或打开 | 低 | 高 | 支持多路径回退 |
| 修复后性能下降 | 低 | 中 | 增加性能测试和优化 |

### 5.2 兼容性风险

| 风险 | 影响范围 | 缓解措施 |
|------|---------|---------|
| 旧版Windows系统API不可用 | Windows 7及以下 | 运行时检测API可用性 |
| 某些应用的TSF实现不标准 | 个别应用 | 使用多策略容错机制 |
| 跨进程权限限制 | 高权限应用 | 文档说明限制场景 |

## 六、成功标准

修复完成后，系统应满足以下标准：

### 6.1 功能标准

| 功能 | 验收标准 |
|------|---------|
| 光标定位 | 在记事本、Word、Chrome中候选窗口位置正确（距离光标±50像素） |
| 候选词查询 | 输入"nihao"能显示"你好"等至少3个候选词 |
| 文字提交 | 在记事本、Word中按空格能正确插入选中的候选词 |
| 错误恢复 | 查询失败或提交失败时不崩溃，能继续使用 |

### 6.2 性能标准

| 指标 | 目标值 |
|------|--------|
| 候选词查询响应时间 | < 50ms（P95） |
| 光标位置获取时间 | < 20ms（P95） |
| 文字提交延迟 | < 100ms（用户感知） |
| 内存占用 | < 50MB（常驻） |

### 6.3 日志标准

| 要求 | 标准 |
|------|------|
| 关键操作覆盖 | 所有P0/P1功能都有日志记录 |
| 错误可诊断 | 任何失败都能通过日志定位原因 |
| 性能影响 | 日志开销 < 5%性能损耗 |

## 七、后续优化方向

修复完成后可考虑的增强功能：

1. **智能位置调整** - 检测候选窗口是否超出屏幕边界，自动调整位置
2. **多屏支持** - 正确处理多显示器场景的坐标转换
3. **高DPI适配** - 在高分辨率屏幕上正确缩放候选窗口
4. **性能优化** - 缓存常用查询结果，减少数据库访问
5. **用户配置** - 允许用户调整候选窗口位置偏移量

## 八、附录

### 8.1 相关TSF API参考

| API | 用途 | 返回值 |
|-----|------|--------|
| ITfContextView::GetTextExt | 获取选区屏幕矩形 | S_OK / TF_E_NOLAYOUT |
| ITfContext::GetSelection | 获取当前选区 | S_OK / E_FAIL |
| ITfRange::SetText | 设置范围文本 | S_OK / E_FAIL |
| ITfComposition::EndComposition | 结束组合 | S_OK / E_UNEXPECTED |
| ITfContext::RequestEditSession | 请求编辑会话 | S_OK / TF_E_SYNCHRONOUS |

### 8.2 关键数据结构

**TF_SELECTION结构**

| 字段 | 类型 | 说明 |
|------|------|------|
| range | ITfRange* | 选区范围对象 |
| style.ase | TF_AE_* | 选区激活状态 |
| style.fInterimChar | BOOL | 是否为临时字符 |

**GUITHREADINFO结构**

| 字段 | 类型 | 说明 |
|------|------|------|
| hwndFocus | HWND | 焦点窗口句柄 |
| rcCaret | RECT | 光标客户区矩形 |

### 8.3 错误码对照表

| HRESULT | 值 | 含义 | 处理方式 |
|---------|-----|------|---------|
| S_OK | 0x00000000 | 成功 | 继续执行 |
| E_FAIL | 0x80004005 | 通用失败 | 记录日志，尝试回退方案 |
| E_UNEXPECTED | 0x8000FFFF | 意外状态 | 清理状态，重置组合 |
| TF_E_SYNCHRONOUS | 0x80040400 | 不支持同步请求 | 使用异步方案 |
| TF_E_NOLAYOUT | 0x80040402 | 无布局信息 | 尝试其他光标获取策略 |
